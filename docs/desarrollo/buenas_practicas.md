# Buenas Pr√°cticas y Patrones del Sistema

Este documento explica **por qu√©** usamos ciertos patrones y pr√°cticas en el sistema, no solo **c√≥mo** usarlos.

---

## üéØ Filosof√≠a General

### Principio DRY (Don't Repeat Yourself)

**Problema que resuelve:** C√≥digo duplicado es dif√≠cil de mantener. Un cambio requiere actualizar m√∫ltiples lugares, lo que lleva a bugs e inconsistencias.

**C√≥mo lo aplicamos:**
- Actions para l√≥gica de negocio reutilizable
- Traits para funcionalidad compartida entre componentes
- Query Builders para queries repetitivas
- Componentes Blade para UI consistente

**Ejemplo real:**
```php
// ‚ùå ANTES: C√≥digo de eliminaci√≥n duplicado en 6 m√©todos
public function deleteEquipo() {
    $this->authorize('delete', $equipo);
    $oldValues = $equipo->toArray();
    $equipo->delete();
    ModelAudited::dispatch('delete', $equipo, $oldValues, null);
    // ... 15 l√≠neas m√°s
}

// ‚úÖ DESPU√âS: Reutilizamos la Action
public function deleteEquipo() {
    $result = app(DeleteModelAction::class)->execute($equipo);
    // ... 1 l√≠nea, l√≥gica centralizada
}
```

**Beneficio:** Cambio en 1 lugar = actualizaci√≥n en todo el sistema.

---

## üß© Actions (L√≥gica de Negocio)

### Por Qu√© Usamos Actions

**Problema:** La l√≥gica de negocio compleja (eliminar, auditar, notificar) estaba esparcida en m√∫ltiples componentes.

**Soluci√≥n:** Actions encapsulan operaciones de negocio completas.

**Beneficios:**

1. **Testing M√°s F√°cil**
```php
// Puedes testear la Action aisladamente
public function test_delete_action()
{
    $modelo = Modelo::factory()->create();
    $result = app(DeleteModelAction::class)->execute($modelo);
    
    $this->assertTrue($result['success']);
    $this->assertSoftDeleted($modelo);
}
```

2. **Reutilizaci√≥n en Cualquier Contexto**
```php
// Desde un componente Livewire
app(DeleteModelAction::class)->execute($modelo);

// Desde un comando de consola
app(DeleteModelAction::class)->executeBulk($modelos);

// Desde un Job
app(DeleteModelAction::class)->execute($modelo, authorize: false);
```

3. **Consistencia Garantizada**
Todos los lugares que eliminan modelos usan la misma l√≥gica de auditor√≠a, autorizaci√≥n y notificaci√≥n.

---

## üé® Traits (Funcionalidad Compartida)

### Por Qu√© Usamos Traits

**Problema:** Cada nuevo CRUD requer√≠a reimplementar las mismas funcionalidades: formularios, ordenamiento, papelera, etc.

**Soluci√≥n:** Traits proporcionan funcionalidad "plug-and-play".

**Ejemplo real - WithCrudOperations:**

```php
// ‚ùå ANTES: ~500 l√≠neas por componente CRUD
class GestionarEquipos extends Component
{
    // 25+ propiedades
    public string $sortField = 'id';
    public bool $showingTrash = false;
    public bool $showFormModal = false;
    // ... m√°s propiedades
    
    // 40+ m√©todos
    public function create() { /* 10 l√≠neas */ }
    public function edit($id) { /* 15 l√≠neas */ }
    public function save() { /* 20 l√≠neas */ }
    public function delete($id) { /* 15 l√≠neas */ }
    public function sortBy($field) { /* 10 l√≠neas */ }
    public function toggleTrash() { /* 8 l√≠neas */ }
    // ... m√°s m√©todos
}

// ‚úÖ DESPU√âS: ~50 l√≠neas por componente CRUD
class GestionarEquipos extends Component
{
    use WithCrudOperations; // ¬°Incluye todo lo anterior!
    
    // Solo implementas lo espec√≠fico del modelo
    protected function getModelClass(): string { return Equipo::class; }
    protected function setFormModel($model): void { $this->form->setEquipo($model); }
    protected function auditFormSave(?array $oldValues): void { /* auditor√≠a */ }
}
```

**Beneficios:**

1. **Reducci√≥n Masiva de C√≥digo**
De ~500 l√≠neas a ~50 l√≠neas por CRUD.

2. **Desarrollo M√°s R√°pido**
De 4-6 horas a 30-60 minutos por CRUD completo.

3. **Mantenimiento Centralizado**
Bug fix en el trait = actualizaci√≥n en todos los CRUDs autom√°ticamente.

4. **Modularidad**
Puedes usar los traits individualmente si solo necesitas una funcionalidad espec√≠fica:
```php
class SoloNecesitoOrdenamiento extends Component
{
    use HasSorting; // Solo ordenamiento, nada m√°s
}
```

---

## üîç Query Builders Personalizados

### Por Qu√© Usamos Query Builders

**Problema:** Las queries complejas se repet√≠an m√∫ltiples veces con peque√±as variaciones.

**Ejemplo real:**

```php
// ‚ùå ANTES: Esta query se repet√≠a 4 veces en el componente
Equipo::query()
    ->when($this->search, fn($q) => $q->where('nombre', 'like', '%' . $this->search . '%'))
    ->when($this->showingTrash, fn($q) => $q->onlyTrashed())
    ->orderBy($this->sortField, $this->sortDirection->value)
    ->paginate(10);

// ‚úÖ DESPU√âS: Query reutilizable y legible
Equipo::query()
    ->filtered($this->search, $this->showingTrash, $this->sortField, $this->sortDirection->value)
    ->paginate(10);
```

**Beneficios:**

1. **Eliminaci√≥n de Duplicaci√≥n**
La misma query se usa en paginaci√≥n, conteo, selecci√≥n, etc.

2. **Legibilidad**
`->filtered(...)` es m√°s legible que m√∫ltiples `->when(...)`.

3. **Testabilidad**
```php
public function test_search_filters_correctly()
{
    $equipo1 = Equipo::factory()->create(['nombre' => 'Mancuernas']);
    $equipo2 = Equipo::factory()->create(['nombre' => 'Barra']);
    
    $results = Equipo::query()->search('Manc')->get();
    
    $this->assertCount(1, $results);
}
```

4. **Composici√≥n Fluida**
```php
Equipo::query()
    ->search('Manc')
    ->trash(true)
    ->sortBy('nombre', 'desc')
    ->active()
    ->get();
```

---

## ‚ö° Computed Properties (Livewire v3)

### Por Qu√© Usamos Computed Properties

**Problema:** M√©todos costosos (queries, c√°lculos) se ejecutaban m√∫ltiples veces durante un mismo render.

**Ejemplo real:**

```php
// ‚ùå ANTES: selectedCount() se llama 6 veces en la vista
public function selectedCount(): int
{
    if ($this->selectingAll) {
        return $this->getTotalFilteredCount() - count($this->exceptItems);
    }
    return count($this->selectedItems);
}

// En vista:
{{ $this->selectedCount() }} // Llamada 1
{{ $this->selectedCount() }} // Llamada 2 - recalcula todo
{{ $this->selectedCount() }} // Llamada 3 - recalcula todo
// ... 3 veces m√°s
```

**Resultado:** 6 ejecuciones del m√©todo = potencialmente 6 queries a DB.

```php
// ‚úÖ DESPU√âS: Con Computed Property
#[Computed]
public function selectedCount(): int
{
    if ($this->selectingAll) {
        return $this->totalFilteredCount - count($this->exceptItems);
    }
    return count($this->selectedItems);
}

// En vista:
{{ $this->selectedCount }} // Llamada 1 - calcula y cachea
{{ $this->selectedCount }} // Llamada 2 - usa cach√©
{{ $this->selectedCount }} // Llamada 3 - usa cach√©
```

**Resultado:** 1 ejecuci√≥n del m√©todo = 1 query m√°ximo. Las dem√°s usan cach√©.

**Beneficio:** Reducci√≥n significativa de overhead de c√°lculos y queries.

---

## üìä WithAuditLogging Trait

### Por Qu√© Centralizamos la Auditor√≠a

**Problema:** El c√≥digo de auditor√≠a era inconsistente y estaba duplicado en m√∫ltiples lugares.

**Ejemplo real:**

```php
// ‚ùå ANTES: C√≥digo de auditor√≠a manual en cada operaci√≥n
if ($this->form->equipo->wasRecentlyCreated) {
    ModelAudited::dispatch('create', $this->form->equipo, null, $this->form->equipo->toArray());
} else {
    ModelAudited::dispatch('update', $this->form->equipo, $oldValues, $this->form->equipo->toArray());
}

// ‚úÖ DESPU√âS: Trait maneja todo autom√°ticamente
$this->auditSave($this->form->equipo, $oldValues);
```

**Beneficios:**

1. **Consistencia Garantizada**
Todos usan el mismo formato de auditor√≠a.

2. **Menos Errores**
No hay riesgo de olvidar auditar una operaci√≥n.

3. **C√≥digo M√°s Limpio**
M√©todos sem√°nticos: `auditCreate()`, `auditUpdate()`, `auditDelete()`.

---

## üé® Componentes Blade Reutilizables

### Por Qu√© Componentes Blade

**Problema:** Bloques HTML repetitivos en todas las vistas.

**Ejemplo real:**

```blade
{{-- ‚ùå ANTES: Repetido 20 veces en cada tabla --}}
<td class="w-4 p-4">
    <input 
        wire:model.live="selectedItems" 
        value="{{ $equipo->id }}" 
        type="checkbox" 
        class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500"
    >
</td>

{{-- ‚úÖ DESPU√âS: Componente reutilizable --}}
<x-table-checkbox :value="$equipo->id" />
```

**Beneficios:**

1. **Consistencia UI**
Todos los checkboxes se ven y comportan igual.

2. **Mantenibilidad**
Cambiar el estilo en 1 componente = actualiza todas las tablas.

3. **Menos C√≥digo**
```blade
{{-- Antes: 200 l√≠neas de HTML repetitivo --}}
{{-- Despu√©s: 50 l√≠neas usando componentes --}}
{{-- Reducci√≥n: 75% --}}
```

---

## üî¢ Constantes en Lugar de Valores M√°gicos

### Por Qu√© Evitamos N√∫meros M√°gicos

**Problema:** Valores hardcodeados sin contexto.

**Ejemplo real:**

```php
// ‚ùå ANTES: ¬øQu√© es 10?
->paginate(10);

// ‚úÖ DESPU√âS: Sem√°ntico y claro
private const PER_PAGE = 10;
->paginate(self::PER_PAGE);
```

**Beneficios:**

1. **Autodocumentaci√≥n**
```php
/** N√∫mero de registros por p√°gina */
private const PER_PAGE = 10;
```

2. **F√°cil de Cambiar**
```php
// Cambio en 1 lugar:
private const PER_PAGE = 20;

// Afecta todos los usos autom√°ticamente
```

3. **Evita Errores**
```php
// ‚ùå F√°cil equivocarse:
if ($count > 10) { /* ... */ } // ¬øEs este el mismo 10?

// ‚úÖ Obvio:
if ($count > self::PER_PAGE) { /* ... */ }
```

---

## üîÑ WithBulkActions Trait

### Por Qu√© Optimizamos la Selecci√≥n Masiva

**Problema:** Cargar miles de IDs en memoria para selecciones masivas causaba problemas de rendimiento.

**Soluci√≥n:** Modo "selectingAll" con lista de excepciones.

**Ejemplo real:**

```php
// ‚ùå ANTES: Cargar 10,000 IDs en memoria
$this->selectedItems = Equipo::pluck('id')->toArray(); // Array de 10,000 elementos

// Eliminar seleccionados
Equipo::whereIn('id', $this->selectedItems)->delete(); // Query lenta con array gigante

// ‚úÖ DESPU√âS: Usa query directa
if ($this->selectingAll) {
    $query = Equipo::query()->applyFilters($this->search, $this->showingTrash);
    if (count($this->exceptItems) > 0) {
        $query->whereNotIn('id', $this->exceptItems); // Solo excluye unos pocos
    }
    $query->delete(); // Query eficiente
}
```

**Beneficio:** Maneja eficientemente desde 10 hasta 10,000+ registros sin consumir memoria excesiva.

---

## üìù Estructura de Archivos

### Por Qu√© Esta Organizaci√≥n

```
app/
‚îú‚îÄ‚îÄ Actions/              # L√≥gica de negocio reutilizable
‚îú‚îÄ‚îÄ Livewire/
‚îÇ   ‚îú‚îÄ‚îÄ Forms/           # Validaci√≥n y guardado encapsulado
‚îÇ   ‚îî‚îÄ‚îÄ Traits/          # Funcionalidad compartida
‚îî‚îÄ‚îÄ Models/
    ‚îî‚îÄ‚îÄ Builders/        # Queries reutilizables
```

**Beneficios:**

1. **Separaci√≥n de Responsabilidades**
Cada carpeta tiene un prop√≥sito claro.

2. **F√°cil de Encontrar**
¬øBuscas l√≥gica de negocio? ‚Üí Actions
¬øBuscas funcionalidad compartida? ‚Üí Traits
¬øBuscas queries? ‚Üí Builders

3. **Escalabilidad**
F√°cil agregar nuevos componentes sin desorganizar.

---

## ‚úÖ Checklist de Buenas Pr√°cticas

Al crear nuevo c√≥digo, preg√∫ntate:

- [ ] **¬øEstoy duplicando c√≥digo?** ‚Üí Considera crear Action/Trait/Builder
- [ ] **¬øEste m√©todo se usa m√∫ltiples veces en la vista?** ‚Üí Considera Computed Property
- [ ] **¬øEstoy hardcodeando n√∫meros/strings?** ‚Üí Usa constantes
- [ ] **¬øEsta query se repite?** ‚Üí Agr√©gala al Query Builder
- [ ] **¬øEste bloque HTML se repite?** ‚Üí Crea componente Blade
- [ ] **¬øEstoy mezclando l√≥gica de negocio con UI?** ‚Üí Separa en Action
- [ ] **¬øNecesito auditar esta operaci√≥n?** ‚Üí Usa WithAuditLogging trait

---

## üéØ Resultado Final

Siguiendo estas pr√°cticas obtenemos:

- ‚úÖ **C√≥digo DRY:** Sin duplicaci√≥n
- ‚úÖ **Mantenibilidad:** Cambios en 1 lugar
- ‚úÖ **Performance:** Cach√© autom√°tico, queries optimizadas
- ‚úÖ **Testabilidad:** Componentes peque√±os y aislados
- ‚úÖ **Escalabilidad:** F√°cil agregar funcionalidad
- ‚úÖ **Consistencia:** Mismo patr√≥n en todo el sistema
- ‚úÖ **Productividad:** Desarrollo m√°s r√°pido

**El tiempo invertido en seguir estas pr√°cticas se recupera r√°pidamente en velocidad de desarrollo y facilidad de mantenimiento.** üöÄ
